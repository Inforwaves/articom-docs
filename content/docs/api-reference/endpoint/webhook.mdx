---
title: Webhooks
description: Receive real-time notifications about agent events
---

# Webhooks

Webhooks allow you to receive real-time notifications about events happening with your agents. Instead of polling the API, Articom will push event data to your specified endpoint.

## Overview

When an event occurs (like a new conversation or agent response), Articom sends an HTTP POST request to your webhook URL with the event data.

## Setting Up Webhooks

### Create a Webhook

#### Endpoint

```
POST /v1/webhooks
```

#### Request Body

```json
{
  "url": "https://yourapp.com/webhooks/articom",
  "events": ["conversation.started", "message.received"],
  "description": "Production webhook",
  "active": true
}
```

#### Example Request

```bash
curl -X POST https://api.articom.io/v1/webhooks \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "url": "https://yourapp.com/webhooks/articom",
    "events": ["conversation.started", "message.received"],
    "active": true
  }'
```

#### Response

```json
{
  "success": true,
  "data": {
    "id": "webhook_1a2b3c4d5e6f",
    "url": "https://yourapp.com/webhooks/articom",
    "events": ["conversation.started", "message.received"],
    "secret": "whsec_kZXQtYW55IGNhcm5hbCBwbGVhcw",
    "active": true,
    "created_at": "2025-11-20T10:00:00Z"
  }
}
```

## Webhook Events

Available event types:

### Agent Events
- `agent.created` - New agent created
- `agent.updated` - Agent configuration updated
- `agent.deleted` - Agent deleted

### Conversation Events
- `conversation.started` - New conversation initiated
- `conversation.ended` - Conversation completed
- `conversation.transferred` - Transferred to human agent

### Message Events
- `message.received` - User message received
- `message.sent` - Agent response sent
- `message.failed` - Message delivery failed

### Analytics Events
- `analytics.daily_summary` - Daily statistics
- `analytics.threshold_reached` - Usage threshold reached

## Webhook Payload

### Structure

All webhook payloads follow this structure:

```json
{
  "id": "evt_1a2b3c4d5e6f",
  "type": "conversation.started",
  "created_at": "2025-11-20T10:00:00Z",
  "data": {
    // Event-specific data
  }
}
```

### Example Payloads

#### Conversation Started

```json
{
  "id": "evt_1a2b3c4d5e6f",
  "type": "conversation.started",
  "created_at": "2025-11-20T10:00:00Z",
  "data": {
    "conversation_id": "conv_1a2b3c4d5e6f",
    "agent_id": "agent_1a2b3c4d5e6f",
    "user_id": "user_1a2b3c4d5e6f",
    "channel": "web_chat",
    "metadata": {
      "source": "homepage",
      "device": "desktop"
    }
  }
}
```

#### Message Received

```json
{
  "id": "evt_2b3c4d5e6f7g",
  "type": "message.received",
  "created_at": "2025-11-20T10:00:00Z",
  "data": {
    "message_id": "msg_1a2b3c4d5e6f",
    "conversation_id": "conv_1a2b3c4d5e6f",
    "content": "I need help with my order",
    "user_id": "user_1a2b3c4d5e6f",
    "timestamp": "2025-11-20T10:00:00Z"
  }
}
```

## Verifying Webhook Signatures

Articom signs webhooks to verify they're from us. Always verify signatures in production.

### Signature Header

```
X-Articom-Signature: t=1605398400,v1=5257a869e7ecebeda32affa62cdca3fa51cad7e77a0e56ff536d0ce8e108d8bd
```

### Verification Example

#### Node.js

```javascript
const crypto = require('crypto');

function verifyWebhookSignature(payload, signature, secret) {
  const [timestamp, hash] = signature.split(',').reduce((acc, part) => {
    const [key, value] = part.split('=');
    acc[key] = value;
    return acc;
  }, {});

  const signedPayload = `${timestamp}.${payload}`;
  const expectedHash = crypto
    .createHmac('sha256', secret)
    .update(signedPayload)
    .digest('hex');

  return crypto.timingSafeEqual(
    Buffer.from(hash),
    Buffer.from(expectedHash)
  );
}

// Express middleware
app.post('/webhooks/articom', (req, res) => {
  const signature = req.headers['x-articom-signature'];
  const payload = JSON.stringify(req.body);
  
  if (!verifyWebhookSignature(payload, signature, WEBHOOK_SECRET)) {
    return res.status(401).send('Invalid signature');
  }
  
  // Process webhook
  res.json({ received: true });
});
```

#### Python

```python
import hmac
import hashlib
import time

def verify_webhook_signature(payload, signature, secret):
    parts = dict(part.split('=') for part in signature.split(','))
    timestamp = parts['t']
    hash_value = parts['v1']
    
    signed_payload = f"{timestamp}.{payload}"
    expected_hash = hmac.new(
        secret.encode(),
        signed_payload.encode(),
        hashlib.sha256
    ).hexdigest()
    
    return hmac.compare_digest(hash_value, expected_hash)

# Flask example
@app.route('/webhooks/articom', methods=['POST'])
def webhook():
    signature = request.headers.get('X-Articom-Signature')
    payload = request.get_data(as_text=True)
    
    if not verify_webhook_signature(payload, signature, WEBHOOK_SECRET):
        return 'Invalid signature', 401
    
    # Process webhook
    return {'received': True}
```

## Webhook Endpoint Requirements

Your webhook endpoint should:

1. **Respond quickly** (within 5 seconds)
2. **Return 2xx status** to acknowledge receipt
3. **Process asynchronously** for long operations
4. **Handle retries** gracefully (idempotent)
5. **Verify signatures** in production

### Example Implementation

```javascript
app.post('/webhooks/articom', async (req, res) => {
  // 1. Verify signature
  if (!verifySignature(req)) {
    return res.status(401).send('Invalid signature');
  }
  
  // 2. Acknowledge immediately
  res.json({ received: true });
  
  // 3. Process asynchronously
  processWebhookAsync(req.body).catch(err => {
    console.error('Webhook processing error:', err);
  });
});

async function processWebhookAsync(event) {
  switch (event.type) {
    case 'conversation.started':
      await handleConversationStarted(event.data);
      break;
    case 'message.received':
      await handleMessageReceived(event.data);
      break;
  }
}
```

## Managing Webhooks

### List Webhooks

```bash
curl https://api.articom.io/v1/webhooks \
  -H "Authorization: Bearer YOUR_API_KEY"
```

### Update Webhook

```bash
curl -X PATCH https://api.articom.io/v1/webhooks/webhook_1a2b3c4d5e6f \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "events": ["conversation.started", "message.received", "message.sent"]
  }'
```

### Delete Webhook

```bash
curl -X DELETE https://api.articom.io/v1/webhooks/webhook_1a2b3c4d5e6f \
  -H "Authorization: Bearer YOUR_API_KEY"
```

## Testing Webhooks

### Test Endpoint

Send a test event to your webhook:

```bash
curl -X POST https://api.articom.io/v1/webhooks/webhook_1a2b3c4d5e6f/test \
  -H "Authorization: Bearer YOUR_API_KEY"
```

### Local Development

Use tools like ngrok to test webhooks locally:

```bash
# Start ngrok
ngrok http 3000

# Update webhook URL
curl -X PATCH https://api.articom.io/v1/webhooks/webhook_1a2b3c4d5e6f \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -d '{"url": "https://abc123.ngrok.io/webhooks/articom"}'
```

## Retry Logic

- **Failed deliveries** are retried up to 3 times
- **Backoff schedule**: 1min, 5min, 30min
- **Failure reasons** logged in dashboard
- **Auto-disable** after 10 consecutive failures

## Best Practices

1. **Idempotency**: Handle duplicate events gracefully
2. **Quick Response**: Return 200 immediately, process async
3. **Error Handling**: Log failures, don't expose internals
4. **Security**: Always verify signatures
5. **Monitoring**: Track webhook success/failure rates

## Next Steps

<Cards>
  <Card title="Authentication" href="/docs/api-reference/authentication" />
  <Card title="Create Agent" href="/docs/api-reference/endpoint/create" />
  <Card title="Get Agent" href="/docs/api-reference/endpoint/get" />
</Cards>
